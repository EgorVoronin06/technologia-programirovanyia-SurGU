
#include <iostream>
#include <cmath>
#include <bitset>
#include <iomanip>

using namespace std;

// Функция для вывода double в бинарном представлении
void printBinary(double value) {
    /*
    Назначение: Преобразует число double в его двоичное представление согласно стандарту IEEE 754
    Принцип работы:
    1. reinterpret_cast интерпретирует память double как unsigned long long
    2. bitset<64> создает набор из 64 битов этого числа
    3. Выводит биты в порядке от старшего к младшему
    Структура double (64 бита):
    - Бит 63: знак (0 - положительный, 1 - отрицательный)
    - Биты 62-52: экспонента (11 битов, смещение 1023)
    - Биты 51-0: мантисса (52 бита, с подразумеваемой ведущей 1)
    */
    unsigned long long binaryRepresentation = *reinterpret_cast<unsigned long long*>(&value);
    bitset<64> bits(binaryRepresentation);
    cout << bits;
}

int main() {
    // Инициализация переменных
    double x = 0.1;     // Значение x по условию задачи
    double eps;         // Точность вычислений (будет введена пользователем)
    double a;           // Текущий член ряда
    double s = 0.0;     // Сумма ряда (инициализируется нулем)
    int i = 1;          // Счетчик итераций (начинается с 1, так как ряд начинается с i=1)

    // Ввод точности
    cout << "Введите точность (например, 0.0001): ";
    cin >> eps;

    cout << "Вычисление ряда: s = -x³/3 + x⁵/5 - x⁷/7 + ..." << endl;
    cout << "При x = " << x << endl << endl;

    /*
    ВЫЧИСЛЕНИЕ СУММЫ РЯДА
    Ряд: s = -x³/3 + x⁵/5 - x⁷/7 + ... 
    Общая формула: a_i = (-1)^i * x^(2i+1) / (2i+1) для i = 1,2,3,...
    */
    do {
        // Вычисление текущего члена ряда:
        // pow(-1, i) - определяет знак (-1 в степени i)
        // pow(x, 2*i+1) - вычисляет x в степени (2i+1)
        // (2*i+1) - знаменатель
        int power = 2 * i + 1;
        a = pow(-1, i) * pow(x, power) / power;
        s += a; // Добавление члена к общей сумме
        i++;    // Увеличение счетчика итераций
    } while (abs(a) > eps && i < 1000); // Условие продолжения цикла

    /*
    Условие цикла do-while:
    - abs(a) > eps - продолжать пока текущий член ряда больше заданной точности
    - i < 1000 - защита от бесконечного цикла (максимум 1000 итераций)
    */

    // ВЫВОД РЕЗУЛЬТАТОВ
    cout << "\n=== РЕЗУЛЬТАТЫ ===" << endl;
    
    // Вывод в десятичной системе
    cout << fixed << setprecision(10);
    cout << "Сумма ряда: " << s << endl;
    cout << "Количество итераций: " << i - 1 << endl;
    cout << "Точность: " << eps << endl;

    // Аналитическое решение для проверки
    /*
    Математическая интерпретация ряда:
    Данный ряд представляет собой разложение функции arctan(x) без первого члена:
    arctan(x) = x - x³/3 + x⁵/5 - x⁷/7 + ...
    Наш ряд: s = -x³/3 + x⁵/5 - x⁷/7 + ... = arctan(x) - x
    */
    double analytical = atan(x) - x;
    cout << "Аналитическое значение (atan(x) - x): " << analytical << endl;
    cout << "Разность: " << abs(s - analytical) << endl;

    // Вывод в бинарной системе
    cout << "\n=== ДВОИЧНОЕ ПРЕДСТАВЛЕНИЕ ===" << endl;
    cout << "Сумма ряда в бинарной системе: ";
    printBinary(s);
    cout << endl;

    cout << "Точность в бинарной системе: ";
    printBinary(eps);
    cout << endl;

    return 0;
}
